จาก 
import {
  getAllDepartment,
  createDepartment,
} from "@/app/api/setting/department/core/department.controller";
import { checkPermission } from "@/lib/apiAuth";
import { PERMISSIONS } from "@/constants/permissions";

export async function GET(request) {
  const permissionError = await checkPermission(
    request,
    PERMISSIONS.DEPARTMENT_VIEW
  );
  if (permissionError) return permissionError;

  return getAllDepartment(request);
}

export async function POST(request) {
  const permissionError = await checkPermission(
    request,
    PERMISSIONS.DEPARTMENT_CREATE
  );
  if (permissionError) return permissionError;

  return createDepartment(request);
}

export const dynamic = "force-dynamic";
และ
import {
  getDepartmentById,
  updateDepartment,
} from "@/app/api/setting/department/core/department.controller";
import { checkPermission } from "@/lib/apiAuth";
import { PERMISSIONS } from "@/constants/permissions";

export async function GET(request, context) {
  const permissionError = await checkPermission(
    request,
    PERMISSIONS.DEPARTMENT_VIEW
  );
  if (permissionError) return permissionError;

  const { departmentId } = await context.params;
  return getDepartmentById(request, departmentId);
}

export async function PUT(request, context) {
  const permissionError = await checkPermission(
    request,
    PERMISSIONS.DEPARTMENT_UPDATE
  );
  if (permissionError) return permissionError;

  const { departmentId } = await context.params;
  return updateDepartment(request, departmentId);
}

export const dynamic = "force-dynamic";
และ
import { NextResponse } from "next/server";
import {
  GetAllDepartmentUseCase,
  GetDepartmentByIdUseCase,
  CreateDepartmentUseCase,
  UpdateDepartmentUseCase,
} from "@/app/api/setting/department/usecases/departments.usecase";
import { formatDepartmentData } from "@/app/api/setting/department/core/department.schema";
import logger from "@/lib/logger.node";

export async function getAllDepartment(request) {
  try {
    const { searchParams } = new URL(request.url);
    const page = parseInt(searchParams.get("page") || "1", 10);
    const limit = parseInt(searchParams.get("limit") || "1000000", 10);

    const { departments, total } = await GetAllDepartmentUseCase(page, limit);
    return NextResponse.json({
      message: "Success",
      total,
      page,
      limit,
      departments: formatDepartmentData(departments),
    });
  } catch (error) {
    logger.error(error);
    return NextResponse.json(
      { error: error.message },
      { status: error.status || 500 }
    );
  }
}

export async function getDepartmentById(request, departmentId) {
  try {
    const department = await GetDepartmentByIdUseCase(departmentId);
    return NextResponse.json({
      message: "Success",
      department: formatDepartmentData([department])[0],
    });
  } catch (error) {
    logger.error(error);
    return NextResponse.json(
      { error: error.message },
      { status: error.status || 500 }
    );
  }
}

export async function createDepartment(request) {
  try {
    const data = await request.json();
    const department = await CreateDepartmentUseCase(data);
    return NextResponse.json({
      message: "Created",
      department: formatDepartmentData([department])[0],
    });
  } catch (error) {
    logger.error(error);
    return NextResponse.json(
      { error: error.message },
      { status: error.status || 500 }
    );
  }
}

export async function updateDepartment(request, departmentId) {
  try {
    const data = await request.json();
    const department = await UpdateDepartmentUseCase({ ...data, departmentId });
    return NextResponse.json({
      message: "Updated",
      department: formatDepartmentData([department])[0],
    });
  } catch (error) {
    logger.error(error);
    return NextResponse.json(
      { error: error.message },
      { status: error.status || 500 }
    );
  }
}
และ
import prisma from "@/lib/prisma";
import logger from "@/lib/logger.node";

export const DepartmentRepository = {
  getAll: async (skip = 0, take = 10) => {
    logger.info({ message: "DepartmentRepository.getAll", skip, take });
    return await prisma.department.findMany({
      skip,
      take,
      orderBy: { departmentCreatedAt: "asc" },
      include: {
        createdByUser: {
          select: { userId: true, userFirstName: true, userLastName: true },
        },
        updatedByUser: {
          select: { userId: true, userFirstName: true, userLastName: true },
        },
      },
    });
  },

  countAll: async () => prisma.department.count(),

  findById: async (departmentId) => {
    logger.info({ message: "DepartmentRepository.findById", departmentId });
    return await prisma.department.findUnique({
      where: { departmentId },
      include: {
        createdByUser: {
          select: { userId: true, userFirstName: true, userLastName: true },
        },
        updatedByUser: {
          select: { userId: true, userFirstName: true, userLastName: true },
        },
      },
    });
  },

  findByDepartmentName: async (departmentName) => {
    logger.info({ message: "DepartmentRepository.findByDepartmentName", departmentName });
    return await prisma.department.findFirst({
      where: {
        departmentName: { equals: departmentName.trim(), mode: "insensitive" },
      },
    });
  },

  create: async (data) => {
    logger.info({ message: "DepartmentRepository.create", data });
    return await prisma.department.create({
      data,
      include: {
        createdByUser: {
          select: { userId: true, userFirstName: true, userLastName: true },
        },
      },
    });
  },

  update: async (departmentId, data) => {
    logger.info({ message: "DepartmentRepository.update", departmentId });
    return await prisma.department.update({
      where: { departmentId },
      data,
      include: {
        updatedByUser: {
          select: { userId: true, userFirstName: true, userLastName: true },
        },
      },
    });
  },
};
และ
import { z } from "zod";
import { preprocessString, preprocessEnum, formatData } from "@/lib/zodSchema";
import logger from "@/lib/logger.node";

logger.info({ message: "Department schema loaded" });

export const departmentPostSchema = z.object({
  departmentName: preprocessString("Please provide the department name"),
  departmentCreatedBy: preprocessString("Please provide the creator ID"),
});

export const departmentPutSchema = z.object({
  departmentId: preprocessString("Please provide the department ID"),
  departmentName: preprocessString("Please provide the department name"),
  departmentStatus: preprocessEnum(
    ["Enable", "Disable"],
    "Please provide department status'"
  ),
  departmentUpdatedBy: preprocessString("Please provide the updater ID"),
});

export const formatDepartmentData = (departments) => {
  logger.info({
    message: "Formatting department data",
    count: departments.length,
  });
  return formatData(
    departments,
    ["departmentCreatedAt", "departmentUpdatedAt"],
    []
  );
};
และ
import { DepartmentRepository } from "@/app/api/setting/department/core/department.repository";
import logger from "@/lib/logger.node";

export class DepartmentService {
  static async getAllPaginated(skip, take) {
    logger.info({ message: "DepartmentService.getAllPaginated", skip, take });
    return await DepartmentRepository.getAll(skip, take);
  }

  static async countAll() {
    logger.info({ message: "DepartmentService.countAll" });
    return await DepartmentRepository.countAll();
  }

  static async getById(departmentId) {
    logger.info({ message: "DepartmentService.getById", departmentId });
    return await DepartmentRepository.findById(departmentId);
  }

  static async getByName(departmentName) {
    logger.info({ message: "DepartmentService.getByName", departmentName });
    return await DepartmentRepository.findByDepartmentName(departmentName);
  }

  static async create(data) {
    logger.info({ message: "DepartmentService.create", data });
    if (!data.departmentName || !data.departmentCreatedBy)
      throw new Error(
        "Missing required fields: departmentName, departmentCreatedBy"
      );

    return await DepartmentRepository.create(data);
  }

  static async update(departmentId, data) {
    logger.info({ message: "DepartmentService.update", departmentId, data });
    if (!data.departmentName || !data.departmentUpdatedBy)
      throw new Error(
        "Missing required fields: departmentName, departmentStatus, departmentUpdatedBy"
      );

    return await DepartmentRepository.update(departmentId, data);
  }
}
และ
import { DepartmentRepository } from "@/app/api/setting/department/core/department.repository";
import logger from "@/lib/logger.node";

export const DepartmentValidator = {
  async isDuplicateDepartmentName(departmentName) {
    logger.info({
      message: "DepartmentValidator.isDuplicateDepartmentName",
      departmentName,
    });

    if (!departmentName || typeof departmentName !== "string") {
      logger.warn({ message: "Invalid department name input", departmentName });
      throw new Error("Invalid department name");
    }

    const existing = await DepartmentRepository.findByDepartmentName(departmentName);
    const isDuplicate = !!existing;

    if (isDuplicate)
      logger.warn({
        message: "Duplicate department name detected",
        departmentName,
      });
    else logger.info({ message: "Department name available", departmentName });

    return isDuplicate;
  },
};
และ
import { DepartmentService } from "@/app/api/setting/department/core/department.service";
import {
  departmentPostSchema,
  departmentPutSchema,
} from "@/app/api/setting/department/core/department.schema";
import { DepartmentValidator } from "@/app/api/setting/department/core/department.validator";
import { getLocalNow } from "@/lib/getLocalNow";
import logger from "@/lib/logger.node";

export async function GetAllDepartmentUseCase(page = 1, limit = 1000000) {
  const skip = (page - 1) * limit;
  const departments = await DepartmentService.getAllPaginated(skip, limit);
  const total = await DepartmentService.countAll();

  logger.info({ message: "GetAllDepartmentUseCase success", total });
  return { departments, total };
}

export async function GetDepartmentByIdUseCase(departmentId) {
  if (!departmentId || typeof departmentId !== "string")
    throw { status: 400, message: "Invalid department ID" };

  const department = await DepartmentService.getById(departmentId);
  if (!department) throw { status: 404, message: "Department not found" };

  logger.info({ message: "GetDepartmentByIdUseCase success", departmentId });
  return department;
}

export async function CreateDepartmentUseCase(data) {
  logger.info({ message: "CreateDepartmentUseCase start", data });

  const parsed = departmentPostSchema.safeParse(data);
  if (!parsed.success) {
    logger.warn({
      message: "Validation failed",
      errors: parsed.error.flatten().fieldErrors,
    });
    throw {
      status: 422,
      message: "Invalid input",
      details: parsed.error.flatten().fieldErrors,
    };
  }

  const duplicate = await DepartmentValidator.isDuplicateDepartmentName(
    parsed.data.departmentName
  );
  if (duplicate)
    throw {
      status: 409,
      message: `Department '${parsed.data.departmentName}' already exists`,
    };

  const department = await DepartmentService.create({
    departmentName: parsed.data.departmentName.trim(),
    departmentCreatedBy: parsed.data.departmentCreatedBy,
    departmentCreatedAt: getLocalNow(),
  });

  logger.info({
    message: "Department created successfully",
    departmentId: department.departmentId,
  });

  return department;
}

export async function UpdateDepartmentUseCase(data) {
  logger.info({ message: "UpdateDepartmentUseCase start", data });

  const parsed = departmentPutSchema.safeParse(data);
  if (!parsed.success) {
    logger.warn({
      message: "Validation failed",
      errors: parsed.error.flatten().fieldErrors,
    });
    throw {
      status: 422,
      message: "Invalid input",
      details: parsed.error.flatten().fieldErrors,
    };
  }

  const existing = await DepartmentService.getById(parsed.data.departmentId);
  if (!existing) throw { status: 404, message: "Department not found" };

  if (
    parsed.data.departmentName.trim().toLowerCase() !==
    existing.departmentName.trim().toLowerCase()
  ) {
    const duplicate = await DepartmentValidator.isDuplicateDepartmentName(
      parsed.data.departmentName
    );
    if (duplicate)
      throw {
        status: 409,
        message: `Department '${parsed.data.departmentName}' already exists`,
      };
  }

  const updatedDepartment = await DepartmentService.update(
    parsed.data.departmentId,
    {
      departmentName: parsed.data.departmentName.trim(),
      departmentStatus: parsed.data.departmentStatus.trim(),
      departmentUpdatedBy: parsed.data.departmentUpdatedBy,
      departmentUpdatedAt: getLocalNow(),
    }
  );

  logger.info({
    message: "Department updated successfully",
    departmentId: parsed.data.departmentId,
  });

  return updatedDepartment;
}
และ
export * from "./useDepartments";
และ
"use client";
import { useState, useEffect, useCallback } from "react";
import { showToast } from "@/components/UIToast";
import { useRouter } from "next/navigation";

export function useDepartments(apiUrl = "/api/setting/department") {
  const [departments, setDepartments] = useState([]);
  const [loading, setLoading] = useState(true);
  const router = useRouter();

  useEffect(() => {
    let active = true;

    (async () => {
      try {
        const res = await fetch(apiUrl, {
          headers: {
            "x-api-key": process.env.NEXT_PUBLIC_SECRET_TOKEN || "",
          },
        });

        if (res.status === 403) {
          showToast("warning", "You don't have permission to view this page.");
          router.push("/forbidden");
          return;
        }

        const data = await res.json();
        if (!res.ok)
          throw new Error(data.error || "Failed to load departments.");

        if (active) {
          const formatted = Array.isArray(data.departments)
            ? data.departments.map((department, index) => ({
                ...department,
                departmentIndex: index + 1,
                departmentCreatedBy: department.createdByUser
                  ? `${department.createdByUser.userFirstName} ${department.createdByUser.userLastName}`
                  : "-",
                departmentUpdatedBy: department.updatedByUser
                  ? `${department.updatedByUser.userFirstName} ${department.updatedByUser.userLastName}`
                  : "-",
              }))
            : [];
          setDepartments(formatted);
        }
      } catch (err) {
        if (active) {
          showToast("danger", "Error: " + err.message);
        }
      } finally {
        if (active) setLoading(false);
      }
    })();

    return () => {
      active = false;
    };
  }, [apiUrl, router]);

  return { departments, loading };
}

export function useDepartment(departmentId) {
  const [department, setDepartment] = useState(null);
  const [loading, setLoading] = useState(true);
  const router = useRouter();

  useEffect(() => {
    if (!departmentId) {
      setLoading(false);
      return;
    }

    let active = true;
    setLoading(true);

    (async () => {
      try {
        const res = await fetch(`/api/setting/department/${departmentId}`, {
          headers: {
            "x-api-key": process.env.NEXT_PUBLIC_SECRET_TOKEN || "",
          },
        });

        if (res.status === 403) {
          showToast("warning", "You don't have permission to view this page.");
          router.push("/forbidden");
          return;
        }

        const result = await res.json();
        if (!res.ok)
          throw new Error(result.error || "Failed to load Department.");

        if (active) {
          const department =
            result.department ||
            (Array.isArray(result.departments) ? result.departments[0] : null);

          if (department) {
            const formatted = {
              ...department,
              departmentCreatedBy: department.createdByUser
                ? `${department.createdByUser.userFirstName} ${department.createdByUser.userLastName}`
                : "-",
              departmentUpdatedBy: department.updatedByUser
                ? `${department.updatedByUser.userFirstName} ${department.updatedByUser.userLastName}`
                : "-",
            };
            setDepartment(formatted);
          } else {
            showToast("warning", "No Department data found.");
          }
        }
      } catch (err) {
        if (active) {
          showToast("danger", "Error: " + err.message);
        }
      } finally {
        if (active) setLoading(false);
      }
    })();

    return () => {
      active = false;
    };
  }, [departmentId, router]);

  return { department, loading };
}

export function useSubmitDepartment({ mode = "create", departmentId, userId }) {
  const router = useRouter();

  return useCallback(
    async (formRef, formData, setErrors) => {
      const byField =
        mode === "create" ? "departmentCreatedBy" : "departmentUpdatedBy";

      const payload = { ...formData, [byField]: userId };
      const url =
        mode === "create"
          ? "/api/setting/department"
          : `/api/setting/department/${departmentId}`;
      const method = mode === "create" ? "POST" : "PUT";

      try {
        const res = await fetch(url, {
          method,
          headers: {
            "Content-Type": "application/json",
            "x-api-key": process.env.NEXT_PUBLIC_SECRET_TOKEN || "",
          },
          body: JSON.stringify(payload),
        });

        if (res.status === 403) {
          showToast(
            "warning",
            "You don't have permission to perform this action."
          );
          router.push("/forbidden");
          return;
        }

        const result = await res.json();
        if (res.ok) {
          showToast("success", result.message || "Success");
          setTimeout(() => router.push("/setting/department"), 1500);
        } else {
          setErrors(result.details || {});
          showToast("danger", result.error || "Failed to submit Department.");
        }
      } catch (err) {
        showToast("danger", `Failed to submit Department: ${err.message}`);
      }
    },
    [mode, departmentId, userId, router]
  );
}
และ
"use client";
import React, { useEffect } from "react";
import { useRouter } from "next/navigation";
import UIDepartmentList from "@/components/setting/department/UIDepartmentList";
import { useDepartments } from "@/app/api/setting/department/hooks";
import { usePermissions } from "@/hooks/usePermissions";
import { PERMISSIONS } from "@/constants/permissions";
import UILoading from "@/components/UILoading";

export default function DepartmentPage() {
  const router = useRouter();
  const { hasPermission } = usePermissions();

  const canView = hasPermission(PERMISSIONS.DEPARTMENT_VIEW);
  const canCreate = hasPermission(PERMISSIONS.DEPARTMENT_CREATE);
  const canUpdate = hasPermission(PERMISSIONS.DEPARTMENT_UPDATE);

  const { departments, loading } = useDepartments();

  useEffect(() => {
    if (!canView) {
      router.push("/forbidden");
    }
  }, [canView, router]);

  const handleAddNew = () => {
    if (canCreate) {
      router.push("/setting/department/create");
    }
  };

  const handleView = (item) => {
    router.push(`/setting/department/view/${item.departmentId}`);
  };

  const handleEdit = (item) => {
    if (canUpdate) {
      router.push(`/setting/department/${item.departmentId}`);
    }
  };

  if (!canView) {
    return <UILoading />;
  }

  return (
    <UIDepartmentList
      headerTopic="Department"
      Departments={departments}
      loading={loading}
      onAddNew={canCreate ? handleAddNew : undefined}
      onView={handleView}
      onEdit={canUpdate ? handleEdit : undefined}
    />
  );
}
และ
"use client";

import React, { useEffect } from "react";
import UIDepartmentForm from "@/components/setting/department/UIDepartmentForm";
import { useSessionUser } from "@/hooks/useSessionUser";
import { useSubmitDepartment } from "@/app/api/setting/department/hooks";
import { useFormHandler } from "@/hooks/useFormHandler";
import { usePermissions } from "@/hooks/usePermissions";
import { PERMISSIONS } from "@/constants/permissions";
import { useRouter } from "next/navigation";
import UILoading from "@/components/UILoading";

export default function DepartmentCreate() {
  const { userId, userName } = useSessionUser();
  const { hasPermission } = usePermissions();
  const router = useRouter();
  const canCreate = hasPermission(PERMISSIONS.DEPARTMENT_CREATE);
  
  const submitDepartment = useSubmitDepartment({ mode: "create", userId });

  const formHandler = useFormHandler(
    {
      departmentName: "",
    },
    submitDepartment
  );

  useEffect(() => {
    if (!canCreate) {
      router.push("/forbidden");
    }
  }, [canCreate, router]);

  if (!canCreate) {
    return <UILoading />;
  }

  return (
    <UIDepartmentForm
      headerTopic="Department Create"
      formHandler={formHandler}
      mode="create"
      operatedBy={userName}
    />
  );
}
และ
"use client";

import React, { useEffect } from "react";
import UIDepartmentForm from "@/components/setting/department/UIDepartmentForm";
import UILoading from "@/components/UILoading";
import { useParams, useRouter } from "next/navigation";
import { useSessionUser } from "@/hooks/useSessionUser";
import {
  useDepartment,
  useSubmitDepartment,
} from "@/app/api/setting/department/hooks";
import { useFormHandler } from "@/hooks/useFormHandler";
import { usePermissions } from "@/hooks/usePermissions";
import { PERMISSIONS } from "@/constants/permissions";

export default function DepartmentUpdate() {
  const { departmentId } = useParams();
  const { userId, userName } = useSessionUser();
  const { hasPermission } = usePermissions();
  const router = useRouter();
  const canUpdate = hasPermission(PERMISSIONS.DEPARTMENT_UPDATE);
  
  const { department, loading } = useDepartment(departmentId);
  const submitDepartment = useSubmitDepartment({
    mode: "update",
    departmentId,
    userId,
  });

  const formHandler = useFormHandler(
    {
      departmentName: "",
      departmentStatus: "",
    },
    submitDepartment
  );

  useEffect(() => {
    if (!canUpdate) {
      router.push("/forbidden");
    }
  }, [canUpdate, router]);

  useEffect(() => {
    if (department) formHandler.setFormData(department);
  }, [department]);

  if (!canUpdate) {
    return <UILoading />;
  }

  if (loading) return <UILoading />;

  return (
    <UIDepartmentForm
      headerTopic="Department Update"
      formHandler={formHandler}
      mode="update"
      operatedBy={userName}
      isUpdate
    />
  );
}
และ
"use client";
import React from "react";
import UIHeader from "@/components/UIHeader";
import DataTable from "@/components/UITable";
import UILoading from "@/components/UILoading";

const columns = [
  { name: "ID", uid: "departmentIndex", sortable: true },
  { name: "DEPARTMENT NAME", uid: "departmentName", sortable: true },
  { name: "STATUS", uid: "departmentStatus", sortable: true },
  { name: "CREATED BY", uid: "departmentCreatedBy", sortable: true },
  { name: "CREATED AT", uid: "departmentCreatedAt", sortable: true },
  { name: "UPDATED BY", uid: "departmentUpdatedBy", sortable: true },
  { name: "UPDATED AT", uid: "departmentUpdatedAt", sortable: true },
  { name: "ACTIONS", uid: "actions" },
];

const statusOptions = [
  { name: "Enable", uid: "Enable" },
  { name: "Disable", uid: "Disable" },
];

const statusColorMap = {
  Enable: "success",
  Disable: "danger",
};

const INITIAL_VISIBLE_COLUMNS = [
  "departmentIndex",
  "departmentName",
  "departmentStatus",
  "actions",
];

export default function UIDepartmentList({
  headerTopic,
  Departments = [],
  loading,
  onAddNew,
  onView,
  onEdit,
}) {
  const total = Departments.length;
  const enabled = Departments.filter(
    (department) => department.departmentStatus === "Enable"
  ).length;
  const disabled = Departments.filter(
    (department) => department.departmentStatus === "Disable"
  ).length;

  const normalized = Array.isArray(Departments)
    ? Departments.map((department, i) => ({
        ...department,
        id: department.departmentId,
        departmentIndex: i + 1,
        departmentCreatedBy: department.createdByUser
          ? `${department.createdByUser.userFirstName} ${department.createdByUser.userLastName}`
          : department.departmentCreatedBy || "-",
        departmentUpdatedBy: department.updatedByUser
          ? `${department.updatedByUser.userFirstName} ${department.updatedByUser.userLastName}`
          : department.departmentUpdatedBy || "-",
        departmentCreatedAt: department.departmentCreatedAt
          ? new Date(department.departmentCreatedAt).toISOString().split("T")[0]
          : "-",
        departmentUpdatedAt: department.departmentUpdatedAt
          ? new Date(department.departmentUpdatedAt).toISOString().split("T")[0]
          : "-",
      }))
    : [];

  return (
    <>
      <UIHeader header={headerTopic} />

      <div className="flex flex-col xl:flex-row items-center justify-center w-full h-fit gap-2">
        <div className="flex flex-col items-center justify-center w-full h-full p-2 gap-2 border-1 border-dark">
          <div className="flex items-center justify-start w-full h-full p-2 gap-2">
            Total Departments
          </div>
          <div className="flex items-center justify-start w-full h-full p-2 gap-2 text-dark text-lg">
            {total}
          </div>
        </div>

        <div className="flex flex-col items-center justify-center w-full h-full p-2 gap-2 border-1 border-dark">
          <div className="flex items-center justify-start w-full h-full p-2 gap-2">
            Enabled Departments
          </div>
          <div className="flex items-center justify-start w-full h-full p-2 gap-2 text-success text-lg">
            {enabled}
          </div>
        </div>

        <div className="flex flex-col items-center justify-center w-full h-full p-2 gap-2 border-1 border-dark">
          <div className="flex items-center justify-start w-full h-full p-2 gap-2">
            Disabled Departments
          </div>
          <div className="flex items-center justify-start w-full h-full p-2 gap-2 text-danger text-lg">
            {disabled}
          </div>
        </div>
      </div>

      <div className="flex flex-col items-center justify-start w-full h-fit gap-2 overflow-auto">
        {loading ? (
          <div className="flex items-center justify-center w-full h-full p-2 gap-2">
            <UILoading />
          </div>
        ) : (
          <DataTable
            columns={columns}
            data={normalized}
            statusOptions={statusOptions}
            statusColorMap={statusColorMap}
            initialVisibleColumns={INITIAL_VISIBLE_COLUMNS}
            searchPlaceholder="Search by department name..."
            emptyContent="No departments found"
            itemName="departments"
            onAddNew={onAddNew}
            onView={onView}
            onEdit={onEdit}
          />
        )}
      </div>
    </>
  );
}
และ
"use client";
import UIHeader from "@/components/UIHeader";
import React from "react";
import { Button, Input, Select, SelectItem } from "@heroui/react";

export default function UIDepartmentForm({
  headerTopic,
  formHandler,
  mode,
  isUpdate,
  operatedBy,
}) {
  const { formRef, formData, handleChange, handleSubmit, errors } = formHandler;

  return (
    <>
      <UIHeader header={headerTopic} />

      <form
        ref={formRef}
        onSubmit={handleSubmit}
        className="flex flex-col items-center justify-start w-full h-full overflow-auto"
      >
        <div className="flex flex-col items-center justify-start w-full h-fit gap-2 overflow-auto">
          <div className="flex flex-row items-center justify-center w-full h-fit p-2 gap-2">
            <div className="flex items-center justify-end w-full h-full p-2 gap-2">
              {mode === "create"
                ? `Create By : ${operatedBy}`
                : `Update By : ${operatedBy}`}
            </div>
          </div>

          <div className="flex flex-col xl:flex-row items-center justify-center w-full h-fit p-2 gap-2">
            <div className="flex items-center justify-center w-full h-full p-2 gap-2">
              <Input
                name="departmentName"
                type="text"
                label="Department Name"
                color="default"
                variant="faded"
                radius="none"
                labelPlacement="outside"
                placeholder="Enter Department Name"
                isRequired
                value={formData.departmentName}
                onChange={handleChange("departmentName")}
                isInvalid={!!errors.departmentName}
                errorMessage={errors.departmentName}
              />
            </div>
          </div>

          {isUpdate && (
            <div className="flex flex-col xl:flex-row items-center justify-end w-full h-fit p-2 gap-2">
              <div className="flex items-center justify-center w-full xl:w-6/12 h-full p-2 gap-2">
                <Select
                  name="departmentStatus"
                  label="Department Status"
                  labelPlacement="outside"
                  placeholder="Please Select"
                  color="default"
                  variant="faded"
                  radius="none"
                  isRequired
                  selectedKeys={
                    formData.departmentStatus ? [formData.departmentStatus] : []
                  }
                  onSelectionChange={(keys) =>
                    handleChange("departmentStatus")([...keys][0])
                  }
                  isInvalid={!!errors.departmentStatus}
                  errorMessage={errors.departmentStatus}
                >
                  <SelectItem key="Enable">Enable</SelectItem>
                  <SelectItem key="Disable">Disable</SelectItem>
                </Select>
              </div>
            </div>
          )}

          <div className="flex flex-row items-center justify-end w-full h-fit p-2 gap-2">
            <div className="flex items-center justify-center w-full xl:w-2/12 h-full p-2 gap-2">
              <Button
                type="submit"
                color="success"
                radius="none"
                className="w-full p-2 gap-2 text-white font-semibold"
              >
                Submit
              </Button>
            </div>
            <div className="flex items-center justify-center w-full xl:w-2/12 h-full p-2 gap-2">
              <Button
                type="button"
                color="default"
                radius="none"
                className="w-full p-2 gap-2 font-semibold"
                onPress={() => history.back()}
              >
                Cancel
              </Button>
            </div>
          </div>
        </div>
      </form>
    </>
  );
}
และ
export function getUserPermissions(session) {
  if (!session?.user) return [];

  const rolePermissions =
    session.user.roles?.flatMap((role) =>
      role.permissions
        ?.filter((p) => p.status === "Enable")
        .map((p) => p.key)
    ) || [];

  const directPermissions =
    session.user.permissions
      ?.filter((p) => p.status === "Enable")
      .map((p) => p.key) || [];

  return [...new Set([...rolePermissions, ...directPermissions])];
}

export function hasPermission(session, permissionKey) {
  const permissions = getUserPermissions(session);
  return permissions.includes(permissionKey);
}

export function hasAnyPermission(session, permissionKeys) {
  const permissions = getUserPermissions(session);
  return permissionKeys.some((key) => permissions.includes(key));
}

export function hasAllPermissions(session, permissionKeys) {
  const permissions = getUserPermissions(session);
  return permissionKeys.every((key) => permissions.includes(key));
}

export function getAuthorizedMenus(session, menuData) {
  const permissions = getUserPermissions(session);
  const authorized = {};

  for (const [key, menu] of Object.entries(menuData)) {
    if (!menu.requiredPermission || permissions.includes(menu.requiredPermission)) {
      const authorizedSubMenus = menu.subMenus.filter(
        (sub) => !sub.requiredPermission || permissions.includes(sub.requiredPermission)
      );

      if (authorizedSubMenus.length > 0) {
        authorized[key] = {
          ...menu,
          subMenus: authorizedSubMenus,
        };
      }
    }
  }

  return authorized;
}
และ
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/authOptions";
import { NextResponse } from "next/server";
import { getUserPermissions } from "@/lib/permissions";

export async function checkPermission(request, requiredPermission) {
  const session = await getServerSession(authOptions);

  if (!session) {
    return NextResponse.json(
      { success: false, message: "Unauthorized" },
      { status: 401 }
    );
  }

  const permissions = getUserPermissions(session);

  if (!permissions.includes(requiredPermission)) {
    return NextResponse.json(
      { success: false, message: "Forbidden - Insufficient permissions" },
      { status: 403 }
    );
  }

  return null;
}

export function withPermission(handler, requiredPermission) {
  return async (request, context) => {
    const permissionError = await checkPermission(request, requiredPermission);
    if (permissionError) return permissionError;
    
    return handler(request, context);
  };
}
และ
import { PrismaAdapter } from "@next-auth/prisma-adapter";
import CredentialsProvider from "next-auth/providers/credentials";
import bcrypt from "bcryptjs";
import prisma from "@/lib/prisma";

export const authOptions = {
  secret: process.env.NEXTAUTH_SECRET,
  adapter: PrismaAdapter(prisma),

  session: {
    strategy: "jwt",
    maxAge: 60 * 60,
    updateAge: 5 * 60,
  },

  providers: [
    CredentialsProvider({
      name: "Credentials",
      credentials: {
        email: { label: "Email", type: "text" },
        password: { label: "Password", type: "password" },
      },
      async authorize(credentials) {
        const { email, password } = credentials ?? {};
        if (!email || !password)
          throw new Error(
            JSON.stringify({
              message: "Email and password required",
              type: "warning",
            })
          );

        const user = await prisma.user.findUnique({
          where: { userEmail: email },
          include: {
            department: true,
            userRoles: {
              where: { userRoleStatus: "Enable" },
              include: {
                role: {
                  include: {
                    rolePermissions: {
                      where: { rolePermissionStatus: "Enable" },
                      include: {
                        permission: true,
                      },
                    },
                  },
                },
              },
            },
            userPermissions: {
              where: { userPermissionStatus: "Enable" },
              include: {
                permission: true,
              },
            },
          },
        });

        if (!user)
          throw new Error(
            JSON.stringify({ message: "Email not found", type: "danger" })
          );
        if (user.userStatus !== "Enable")
          throw new Error(
            JSON.stringify({ message: "Account disabled", type: "danger" })
          );

        const match = await bcrypt.compare(password, user.userPassword);
        if (!match)
          throw new Error(
            JSON.stringify({ message: "Incorrect password", type: "danger" })
          );

        return {
          id: user.userId,
          userFirstName: user.userFirstName,
          userLastName: user.userLastName,
          email: user.userEmail,
          status: user.userStatus,
          department: user.department
            ? {
                id: user.department.departmentId,
                name: user.department.departmentName,
                status: user.department.departmentStatus,
              }
            : null,
          roles: user.userRoles.map((ur) => ({
            id: ur.role.roleId,
            name: ur.role.roleName,
            status: ur.role.roleStatus,
            permissions: ur.role.rolePermissions
              .filter((rp) => rp.permission.permissionStatus === "Enable")
              .map((rp) => ({
                id: rp.permission.permissionId,
                name: rp.permission.permissionName,
                key: rp.permission.permissionKey,
                status: rp.permission.permissionStatus,
              })),
          })),
          permissions: user.userPermissions
            .filter((up) => up.permission.permissionStatus === "Enable")
            .map((up) => ({
              id: up.permission.permissionId,
              name: up.permission.permissionName,
              key: up.permission.permissionKey,
              status: up.permission.permissionStatus,
            })),
        };
      },
    }),
  ],

  callbacks: {
    async jwt({ token, user }) {
      const now = Math.floor(Date.now() / 1000);
      const timeout = 60 * 60;

      if (user) {
        token.user = user;
        token.exp = now + timeout;
      } else if (token?.exp && now > token.exp - 300) {
        token.exp = now + timeout;
      }
      return token;
    },

    async session({ session, token }) {
      if (token?.user) {
        session.user = token.user;
        session.expires = new Date(token.exp * 1000).toISOString();
      }
      return session;
    },
  },
};
และ

// constants/permissions.js
export const PERMISSIONS = {
  // Dashboard
  DASHBOARD_VIEW: "dashboard.view",

  // Department
  DEPARTMENT_VIEW: "department.view",
  DEPARTMENT_CREATE: "department.create",
  DEPARTMENT_UPDATE: "department.update",
  DEPARTMENT_DELETE: "department.delete",

  // Role
  ROLE_VIEW: "role.view",
  ROLE_CREATE: "role.create",
  ROLE_UPDATE: "role.update",
  ROLE_DELETE: "role.delete",

  // Permission
  PERMISSION_VIEW: "permission.view",
  PERMISSION_CREATE: "permission.create",
  PERMISSION_UPDATE: "permission.update",
  PERMISSION_DELETE: "permission.delete",

  // Role Permission
  ROLE_PERMISSION_VIEW: "rolePermission.view",
  ROLE_PERMISSION_CREATE: "rolePermission.create",
  ROLE_PERMISSION_UPDATE: "rolePermission.update",
  ROLE_PERMISSION_DELETE: "rolePermission.delete",

  // User
  USER_VIEW: "user.view",
  USER_CREATE: "user.create",
  USER_UPDATE: "user.update",
  USER_DELETE: "user.delete",

  // User Role
  USER_ROLE_VIEW: "userRole.view",
  USER_ROLE_CREATE: "userRole.create",
  USER_ROLE_UPDATE: "userRole.update",
  USER_ROLE_DELETE: "userRole.delete",

  // User Permission
  USER_PERMISSION_VIEW: "userPermission.view",
  USER_PERMISSION_CREATE: "userPermission.create",
  USER_PERMISSION_UPDATE: "userPermission.update",
  USER_PERMISSION_DELETE: "userPermission.delete",

  // PM
  PM_DASHBOARD_VIEW: "pm.dashboard.view",
  PM_MACHINE_VIEW: "pm.machine.view",
  PM_MACHINE_CREATE: "pm.machine.create",
  PM_MACHINE_UPDATE: "pm.machine.update",
  PM_MACHINE_DELETE: "pm.machine.delete",
};
ตอนนี้ที่เข้าใจคือ ถ้าไม่มี Permission จะไม่สามารถทำอะไรได้เลยในฝั่ง Backend ถูกไหม